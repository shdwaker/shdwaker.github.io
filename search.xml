<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vim快捷键总结]]></title>
    <url>%2F2019%2F09%2F28%2FVim%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Vim快捷键总结 常用模式 普通模式(Normal mode) 在普通模式中，可以使用快捷键命令，或按:输入命令行，比如移动光标，删除文本等等。这也是Vim启动后的默认模式。 插入模式(Insert mode) 在这个模式中，大多数按键都会向文本缓冲中插入文本。大多数新用户希望文本编辑器编辑过程中一直保持这个模式。可以输入文本，在正常模式下，按i、a、o等都可以进入插入模式。 可视模式(Visual Mode) 正常模式下按v可以进入可视模式， 在可视模式下，移动光标可以选择文本。按V进入可视行模式， 总是整行整行的选中。ctrl+v进入可视块模式。 命令行模式(Command line mode) 在命令行模式中可以输入会被解释成并执行的文本。例如执行命令（:键），搜索（/和?键）或者过滤命令（!键）。在命令执行之后，Vim返回到命令行模式之前的模式，通常是普通模式。 Ex模式(Ex Mode) 多行的Command-Line模式,普通模式下按Q进入Ex模式。 选择模式(Select Mode) 在gvim下常用的模式，用鼠标拖选区域的时候，就进入了选择模式。和可视模式不同的是，在这个模式下，选择完了高亮区域后，敲任何按键就直接输入并替换选择的文本了。普通模式下，可以按gh进入。 基本插入 快捷键 说明 i 在光标前插入 I 跳到当前行句首进入输入模式 a 在光标后插入 A 跳到当前行句尾进入输入模式 o 跳到下一行并创建新的一行进入输入模式(常用) O 跳到上一行并创建新的一行进入输入模式 r 进入取代模式一次，替换后进入移动模式 R 进入取代模式，直到按Esc后退出进入移动模式 :r filename 在当前位置插入另一个文件的内容 :[n]r filename 在第n行插入另一个文件的内容 :r !date 在光标处插入当前日期与时间。同理，:r !command可以将其它shell命令的输出插入当前文档 tips:按8，再按i，进入插入模式，输入=， 按esc进入命令模式，就会出现8个=。 这在插入分割线时非常有用，如30i+就插入了30个+组成的分割线 改写插入 快捷键 说明 c[n]w 改写光标后1(n)个词 c[n]l 改写光标后n个字母 c[n]h 改写光标前n个字母 [n]cc 修改当前[n]行 [n]s 以输入的文本替代光标之后1(n)个字符，相当于c[n]l [n]S 删除指定数目的行，并以所输入文本代替之 文档操作 快捷键 说明 :e file 关闭当前编辑的文件，并开启新的文件。 如果对当前文件的修改未保存，vi会警告。 :e! file 放弃对当前文件的修改，编辑新的文件。 :e+file 开始新的文件，并从文件尾开始编辑。 :e+n file 开始新的文件，并从第n行开始编辑。 :enew 编译一个未命名的新文档。(CTRL-W n) :e 重新加载当前文档 :e! 重新加载当前文档，并丢弃已做的改动。 :e#或ctrl+^ 回到刚才编辑的文件，很实用。 :f或ctrl+g 显示文档名，是否修改，和光标位置。 :f filename 改变编辑的文件名，这时再保存相当于另存为。 gf 打开以光标所在字符串为文件名的文件。 :w 保存修改。 :n1,n2w filename 选择性保存从某n1行到另n2行的内容。 :wq 保存并退出 ZZ 保存并退出 :x 保存并退出 :q[uit] 退出当前窗口。(CTRL-W q或CTRL-W CTRL-Q) :saveas newfilename 另存为 :browse e 会打开一个文件浏览器让你选择要编辑的文件。 如果是终端中，则会打开netrw的文件浏览窗口； 如果是gvim，则会打开一个图形界面的浏览窗口。 实际上:browse后可以跟任何编辑文档的命令，如sp等。 用browse打开的起始目录可以由browsedir来设置： :set browsedir=last 用上次访问过的目录（默认）； :set browsedir=buffer 用当前文件所在目录； :set browsedir=current 用当前工作目录； :Sex 水平分割一个窗口，浏览文件系统； :Vex 垂直分割一个窗口，浏览文件系统； 光标移动 基本移动 以下移动都是在normal模式下 快捷键 说明 h或退格 左移一个字符； l或空格 右移一个字符； j 下移一行； k 上移一行； gj 移动到一段内的下一行； gk 移动到一段内的上一行； +或Enter 把光标移至下一行第一个非空白字符。 - 把光标移至上一行第一个非空白字符。 w 前移一个单词，光标停在下一个单词开头； W 移动下一个单词开头，但忽略一些标点； e 前移一个单词，光标停在下一个单词末尾； E 移动到下一个单词末尾，如果词尾有标点，则移动到标点； b 后移一个单词，光标停在上一个单词开头； B 移动到上一个单词开头，忽略一些标点； ge 后移一个单词，光标停在上一个单词末尾； gE 同 ge ，不过‘单词’包含单词相邻的标点。 ( 前移1句。 ) 后移1句。 { 前移1段。 } 后移1段。 fc 把光标移到同一行的下一个c字符处 Fc 把光标移到同一行的上一个c字符处 tc 把光标移到同一行的下一个c字符前 Tc 把光标移到同一行的上一个c字符后 ; 配合f &amp; t使用，重复一次 , 配合f &amp; t使用，反向重复一次 上面的操作都可以配合n使用，比如在正常模式(下面会讲到)下输入3h， 则光标向左移动3个字符 快捷键 说明 0 移动到行首。 \ 移动到行首。 g0 移到光标所在屏幕行行首。 ^ 移动到本行第一个非空白字符。 g^ 同 ^ ，但是移动到当前屏幕行第一个非空字符处。 n\ 把光标移到第n列上。 nG 到文件第n行。 H 把光标移到屏幕最顶端一行。 M 把光标移到屏幕中间一行。 L 把光标移到屏幕最底端一行。 gg 到文件头部。 G 到文件尾部。 翻屏 快捷键 说明 ctrl+f 下翻一屏。 ctrl+b 上翻一屏。 ctrl+d 下翻半屏。 ctrl+u 上翻半屏。 ctrl+e 向下滚动一行。 ctrl+y 向上滚动一行。 n% 到文件n%的位置。 zz 将当前行移动到屏幕中央。 zt 将当前行移动到屏幕顶端。 zb 将当前行移动到屏幕底端。 标记 使用标记可以快速移动。到达标记后，可以用Ctrl+o返回原来的位置。 Ctrl+o和Ctrl+i 很像浏览器上的 后退 和 前进 。 快捷键 说明 m{a-z} 标记光标所在位置，局部标记，只用于当前文件。 m{A-Z} 标记光标所在位置，全局标记。标记之后，退出Vim， 重新启动，标记仍然有效。 `{a-z} 移动到标记位置。 ‘{a-z} 移动到标记行的行首。 `{0-9} 回到上[2-10]次关闭vim时最后离开的位置。 `` 移动到上次编辑的位置。”也可以，不过``精确到列，而”精确到行 。如果想跳转到更老的位置，可以按Ctrl+o，跳转到更新的位置用Ctrl+i。 `” 移动到上次离开的地方。 `. 移动到最后改动的地方。 :marks 显示所有标记。 :delmarks a b 删除标记a和b。 :delmarks a-c 删除标记a、b和c。 :delmarks a c-f 删除标记a、c、d、e、f。 :delmarks! 删除当前缓冲区的所有标记。 :help mark-motions 查看更多关于mark的知识。 剪切复制和寄存器 剪切和复制、粘贴 快捷键 说明 [n]x 剪切光标右边n个字符，相当于d[n]l。 [n]X 剪切光标左边n个字符，相当于d[n]h。 y 复制在可视模式下选中的文本。 yy or Y 复制整行文本。 y[n]w 复制一(n)个词。 y[n]l 复制光标右边1(n)个字符。 y[n]h 复制光标左边1(n)个字符。 y 从光标当前位置复制到行尾。 y0 从光标当前位置复制到行首。 m,ny 复制m行到n行的内容。 y1G或ygg 复制光标以上的所有行。 yG 复制光标以下的所有行。 yaw和yas 复制一个词和复制一个句子，即使光标不在词首和句首也没关系。 d 删除（剪切）在可视模式下选中的文本。 d or D 删除（剪切）当前位置到行尾的内容。 d[n]w 删除（剪切）1(n)个单词 d[n]l 删除（剪切）光标右边1(n)个字符。 d[n]h 删除（剪切）光标左边1(n)个字符。 d0 删除（剪切）当前位置到行首的内容 [n] dd 删除（剪切）1(n)行。 m,nd&lt;cr> 剪切m行到n行的内容。 d1G或dgg 剪切光标以上的所有行。 dG 剪切光标以下的所有行。 daw和das 剪切一个词和剪切一个句子，即使光标不在词首和句首也没关系。 d/f&lt;cr> 这是一个比较高级的组合命令，它将删除当前位置 到下一个f之间的内容。 p 在光标之后粘贴。 P 在光标之前粘贴。 文本对象 快捷键 说明 aw 一个词 as 一句。 ap 一段。 ab 一块（包含在圆括号中的）。 y, d, c, v都可以跟文本对象。 寄存器 快捷键 说明 a-z 都可以用作寄存器名。”ayy把当前行的内容放入a寄存器。 A-Z 用大写字母索引寄存器，可以在寄存器中追加内容。 如”Ayy把当前行的内容追加到a寄存器中。 :reg 显示所有寄存器的内容。 “” 不加寄存器索引时，默认使用的寄存器。 “* 当前选择缓冲区，”*yy把当前行的内容放入当前选择缓冲区。 “+ 系统剪贴板。”+yy把当前行的内容放入系统剪贴板。 常用操作 vim中清空文件内容 123命令为：ggdG其中，gg为跳转到文件首行；dG为删除光标所在行以及其下所有行的内容；再细讲，d为删除，G为跳转到文件末尾行 vim中格式化json 123456789101112131415161718:%!python -m json.tool参考：https://blog.csdn.net/qianye2015/article/details/48824981但是如果包含中文，会将中文转换成Unicode，需要执行如下命令:%!python -m json.tool:%!python -c &quot;import re,sys;sys.stdout.write(re.sub(r&apos;\\\u[0-9a-f]&#123;4&#125;&apos;, lambda m:m.group().decode(&apos;unicode_escape&apos;).encode(&apos;utf-8&apos;), sys.stdin.read()))&quot;但是内容太长记不住，可以编辑.vimrc➜ ~ cat ~/.vimrcset nucolorscheme darkbluesyntax onset backspace=2 command! JsonFormat :execute &apos;%!python -m json.tool&apos; \ | :execute &apos;%!python -c &quot;import re,sys;sys.stdout.write(re.sub(r\&quot;\\\u[0-9a-f]&#123;4&#125;\&quot;, lambda m:m.group().decode(\&quot;unicode_escape\&quot;).encode(\&quot;utf-8\&quot;), sys.stdin.read()))&quot;&apos;如此，执行:JsonFormat即可 vim中移动代码块 1234（1）选定文本块，使用v进入可视模式；移动光标键选定内容（2）复制选定块到缓冲区，用y；复制整行，用yy（3）剪切选定块到缓冲区，用d；剪切整行用dd（4）粘贴缓冲区中的内容，用p]]></content>
  </entry>
  <entry>
    <title><![CDATA[Mac Terminal常用快捷键]]></title>
    <url>%2F2019%2F09%2F27%2FMac-Terminal%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%2F</url>
    <content type="text"><![CDATA[Mac 命令行下常用的快捷键总结 快捷键 快捷键/命令 说明 Ctrl + a 移动光标至行首 Ctrl + e 移动光标至行尾 Esc+b 移动到当前单词的开头 Esc+f 移动到当前单词的结尾 Ctrl + l 清屏 clear 清屏 Command + k 清屏 Ctrl + u 删除光标前的所有文字。如果光标位于行尾则删除整行。 Ctrl + h 删除光标所在处前一个字符 Ctrl + k 删除光标后的所有文字 Ctrl + r 检索使用过的命令 Ctrl + c 终止当前执行 Ctrl + d 退出当前shell Ctrl + z 将执行中的任何东西放入后台进程。fg可以将其恢复。 Ctrl + w 删除光标之前的单词 Ctrl + t 将光标前的两个文字进行互换 Option + → 光标向前移动一个单词 Option + ← 光标向后移动一个单词 Esc + t 将光标前的两个单词进行互换 Ctrl+t 颠倒光标所在处及其之前的字符位置，并将光标移动到下一个字符 Tab 自动补全文件或文件夹的名称 Ctrl+v 插入特殊字符,如Ctrl+v+Tab加入Tab字符键 命令历史 快捷键/命令 说明 history n 列出最近执行过的n条命令 ctrl-r 检索之前执行过的命令 ![value] 执行最近以’value’开始的命令 !! 执行最近执行过的命令]]></content>
  </entry>
  <entry>
    <title><![CDATA[域名解析相关命名]]></title>
    <url>%2F2019%2F09%2F23%2F%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E7%9B%B8%E5%85%B3%E5%91%BD%E5%90%8D%2F</url>
    <content type="text"><![CDATA[域名解析相关命名 dig,nslookup,host 什么是DNSDNS：（Domain Name System，域名系统），因特网上作为域名和IP地址相互映射的一个分布式数据库，能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。通过主机名，最终得到该主机名对应的IP地址的过程叫做域名解析（或主机名解析）。使用端口号53。 常见DNS记录类型 类型 说明 A 地址记录，用来指定域名的 IPv4 地址，如果需要将域名指向一个 IP 地址，就需要添加 A 记录 AAAA 用来指定主机名(或域名)对应的 IPv6 地址记录 CNAME 如果需要将域名指向另一个域名，再由另一个域名提供 ip 地址，就需要添加 CNAME 记录。 MX 如果需要设置邮箱，让邮箱能够收到邮件，需要添加 MX 记录。 NS 域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。 SOA SOA 这种记录是所有区域性文件中的强制性记录。它必须是一个文件中的第一个记录。 TXT 可以写任何东西，长度限制为 255。绝大多数的 TXT记录是用来做 SPF 记录(反垃圾邮件)。 dig命令 定义 dig的全称是 (domain information groper)。它是一个用来灵活探测DNS的工具。它会打印出DNS name server的回应。 命令选项 dig [@server] [-b address] [-c class] [-f filename] [-k filename] [ -n ][-p port#] [-t type] [-x addr] [-y name:key] [name] [type] [class] [queryopt...] dig [-h] dig [global-queryopt...] [query...] 选项说明 参数 说明 -b address 设置所要询问地址的源 IP 地址。这必须是主机网络接口上的某一合法的地址。 -c class 缺省查询类（IN for internet）由选项 -c 重设。class 可以是任何合法类，比如查询 Hesiod 记录的 HS 类或查询 CHAOSNET 记录的 CH 类。 -f filename 使 dig 在批处理模式下运行，通过从文件 filename 读取一系列搜索请求加以处理。文件包含许多查询；每行一个。文件中的每一项都应该以和使用命令行接口对 dig 的查询相同的方法来组织。 -h 当使用选项 -h 时，显示一个简短的命令行参数和选项摘要。 -k filename 要签署由 dig 发送的 DNS 查询以及对它们使用事务签名（TSIG）的响应，用 选项 -k 指定 TSIG 密钥文件。 -n 缺省情况下，使用 IP6.ARPA 域和 RFC2874 定义的二进制标号搜索 IPv6 地址。为了使用更早的、 使用 IP6.INT 域和 nibble 标签的 RFC1886 方法，指定 选项 -n（nibble）。 -p port# 如果需要查询一个非标准的端口号，则使用选项 -p。port# 是 dig 将发送其查询的端口号，而不是标准的 DNS 端口号 53。该选项可用于测试已在非标准端口号上配置成侦听查询的域名服务器。 -t type 设置查询类型为 type。可以是 BIND9 支持的任意有效查询类型。缺省查询类型是 A，除非提供 -x 选项来指示一个逆向查询。通过指定 AXFR 的 type 可以请求一个区域传输。当需要增量区域传输（IXFR）时，type 设置为 ixfr=N。增量区域传输将包含自从区域的 SOA 记录中的序列号改为 N 之后对区域所做的更改。 -x addr 逆向查询（将地址映射到名称）可以通过 -x 选项加以简化。addr 是一个 以小数点为界的 IPv4 地址或冒号为界的 IPv6 地址。当使用这个选项时，无需提供 name、class 和 type 参数。dig 自动运行类似11.12.13.10.in-addr.arpa 的域名查询，并分别设置查询类型和类为 PTR 和 IN。 -y name:key 您可以通过命令行上的 -y 选项指定 TSIG 密钥；name 是 TSIG 密码的名称，key 是实际的密码。密码是 64 位加密字符串，通常由 dnssec-keygen（8）生成。当在多用户系统上使用选项 -y 时应该谨慎，因为密码在 ps（1）的输出或 shell 的历史文件中可能是可见的。当同时使用 dig 和 TSCG 认证时，被查询的名称服务器需要知道密码和解码规则。在 BIND 中，通过提供正确的密码和 named.conf 中的服务器声明实现。 查询选项 dig 提供查询选项号，它影响搜索方式和结果显示。一些在查询请求报头设置或复位标志位，一部分决定显示哪些回复信息，其它的决定超时和重试策略。每个查询选项被带前缀（+）的关键字标识。一些关键字设置或复位一个选项。通常前缀是求反关键字含义的字符串no。其他关键字分配各选项的值，比如超时时间间隔。它们的格式形如 +keyword=value。 选项 说明 +[no]tcp 查询域名服务器时使用 [不使用] TCP。缺省行为是使用 UDP，除非是 AXFR 或 IXFR 请求，才使用 TCP 连接。 +[no]vc 查询名称服务器时使用 [不使用] TCP。+[no]tcp 的备用语法提供了向下兼容。 vc 代表虚电路。 +[no]ignore 忽略 UDP 响应的中断，而不是用 TCP 重试。缺省情况运行 TCP 重试。 +domain=somename 设定包含单个域 somename 的搜索列表，好像被 /etc/resolv.conf 中的域伪指令指定，并且启用搜索列表处理，好像给定了 +search 选项。 +[no]search 使用 [不使用] 搜索列表 或 resolv.conf 中的域伪指令（如果有的话）定义的搜索列表。缺省情况不使用搜索列表。 +[no]defname 不建议看作 +[no]search 的同义词。 +[no]aaonly 该选项不做任何事。它用来提供对设置成未实现解析器标志的 dig 的旧版本的兼容性。 +[no]adflag 在查询中设置 [不设置] AD（真实数据）位。目前 AD 位只在响应中有标准含义，而查询中没有，但是出于完整性考虑在查询中这种性能可以设置。 +[no]cdflag 在查询中设置 [不设置] CD（检查禁用）位。它请求服务器不运行响应信息的 DNSSEC 合法性。 +[no]recursive 切换查询中的 RD（要求递归）位设置。在缺省情况下设置该位，也就是说 dig 正常情形下发送递归查询。当使用 查询选项 +nssearch 或 +trace 时，递归自动禁用。 +[no]nssearch 这个选项被设置时，dig 试图寻找包含待搜名称的网段的权威域名服务器，并显示网段中每台域名服务器的 SOA 记录。 +[no]trace 切换为待查询名称从根名称服务器开始的代理路径跟踪。缺省情况不使用跟踪。一旦启用跟踪，dig 使用迭代查询解析待查询名称。它将按照从根服务器的参照，显示来自每台使用解析查询的服务器的应答。 +[no]cmd 设定在输出中显示指出 dig 版本及其所用的查询选项的初始注释。缺省情况下显示注释。 +[no]short 提供简要答复。缺省值是以冗长格式显示答复信息。 +[no]identify 当启用 +short 选项时，显示 [或不显示] 提供应答的 IP 地址和端口号。如果请求简短格式应答，缺省情况不显示提供应答的服务器的源地址和端口号。 +[no]comments 切换输出中的注释行显示。缺省值是显示注释。 +[no]stats 该查询选项设定显示统计信息：查询进行时，应答的大小等等。缺省显示查询统计信息。 +[no]qr 显示 [不显示] 发送的查询请求。缺省不显示。 +[no]question 当返回应答时，显示 [不显示] 查询请求的问题部分。缺省作为注释显示问题部分。 +[no]answer 显示 [不显示] 应答的回答部分。缺省显示。 +[no]authority 显示 [不显示] 应答的权限部分。缺省显示。 +[no]additional 显示 [不显示] 应答的附加部分。缺省显示。 +[no]all 设置或清除所有显示标志。 +time=T 为查询设置超时时间为 T 秒。缺省是5秒。如果将 T 设置为小于1的数，则以1秒作为查询超时时间。 +tries=A 设置向服务器发送 UDP 查询请求的重试次数为 A，代替缺省的 3 次。如果把 A 小于或等于 0，则采用 1 为重试次数。 +ndots=D 出于完全考虑，设置必须出现在名称 D 的点数。缺省值是使用在 /etc/resolv.conf 中的 ndots 语句定义的，或者是 1，如果没有 ndots 语句的话。带更少点数的名称 被解释为相对名称，并通过搜索列表中的域或文件 /etc/resolv.conf 中的域伪指令进行搜索。 +bufsize=B 设置使用 EDNS0 的 UDP 消息缓冲区大小为 B 字节。缓冲区的最大值和最小值分别为 65535 和 0。超出这个范围的值自动舍入到最近的有效值。 +[no]multiline 以详细的多行格式显示类似 SOA 的记录，并附带可读注释。缺省值是每单个行上显示一条记录，以便于计算机解析 dig 的输出。 dig命令的输出 ➜ ~ dig baidu.com ; &lt;&lt;&gt;&gt; DiG 9.8.3-P1 &lt;&lt;&gt;&gt; baidu.com ;; global options: +cmd ;; Got answer: ;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 62920 ;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 5, ADDITIONAL: 5 ;; QUESTION SECTION: ;baidu.com. IN A ;; ANSWER SECTION: baidu.com. 395 IN A 39.156.69.79 baidu.com. 395 IN A 220.181.38.148 ;; AUTHORITY SECTION: baidu.com. 63231 IN NS dns.baidu.com. baidu.com. 63231 IN NS ns7.baidu.com. baidu.com. 63231 IN NS ns2.baidu.com. baidu.com. 63231 IN NS ns3.baidu.com. baidu.com. 63231 IN NS ns4.baidu.com. ;; ADDITIONAL SECTION: dns.baidu.com. 82824 IN A 202.108.22.220 ns2.baidu.com. 2112 IN A 220.181.33.31 ns3.baidu.com. 63366 IN A 112.80.248.64 ns4.baidu.com. 82827 IN A 14.215.178.80 ns7.baidu.com. 63570 IN A 180.76.76.92 ;; Query time: 10 msec ;; SERVER: 192.168.4.189#53(192.168.4.189) ;; WHEN: Mon Sep 23 10:03:24 2019 ;; MSG SIZE rcvd: 229 dig命令的输出大概分为5个部分 part1显示dig命令的版本和输入的参数 part2显示服务返回的一些技术详情，比较重要的是 status。如果 status 的值为 NOERROR 则说明本次查询成功结束。 QUESTION SECTION 显示我们要查询的域名。 ANSWER SECTION 表示查询结果，395是TTL值（Time to live 的缩写），表示缓存时间，即395秒之内不用重新查询。 AUTHORITY SECTION 表示从哪台 DNS 服务器获取到具体的 A 记录信息。记住本地 DNS 服务器只是查询，而 AUTHORITY SECTION 返回的服务器是权威 DNS 服务器，由它来维护 www.baidu.com 的域名信息。返回的 DNS 记录类型是 NS，对应的名称是 dns.baidu.com.，ns7.baidu.com.等。 ADDITIONAL SECTION 表示 NS 服务器对应的 IP 地址，这些 IP 地址对应的服务器安装了 BIND 软件。 Query time 查询耗时 SERVER 表示本地 DNS 服务器地址和端口号 WHEN 查询时间 DNS服务器 首先，本机一定要知道DNS服务器的IP地址，否则上不了网。通过DNS服务器，才能知道某个域名的IP地址到底是什么。 DNS服务器的IP地址，有可能是动态的，每次上网时由网关分配，这叫做DHCP机制；也有可能是事先指定的固定地址。Linux系统里面，DNS服务器的IP地址保存在/etc/resolv.conf文件。 本机只向自己的DNS服务器查询，dig命令有一个@参数，显示向其他DNS服务器查询的结果。如1dig @4.2.2.2 baidu.com 域名的层级 DNS服务器怎么会知道每个域名的IP地址呢？答案是分级查询。 请仔细看前面的例子，每个域名的尾部都多了一个点。这不是疏忽，而是所有域名的尾部，实际上都有一个根域名。 举例来说，www.example.com真正的域名是www.example.com.root，简写www.example.com.。因为，根域名.root对于所有域名都是一样的，所以平时是省略的。 根域名的下一级，叫做”顶级域名”（top-level domain，缩写为TLD），比如.com、.net；再下一级叫做”次级域名”（second-level domain，缩写为SLD），比如www.example.com里面的.example，这一级域名是用户可以注册的；再下一级是主机名（host），比如www.example.com里面的www，又称为&quot;三级域名&quot;，这是用户在自己的域里面为服务器分配的名称，是用户可以任意分配的。123主机名.次级域名.顶级域名.根域名# 即host.sld.tld.root 根域名服务器 DNS服务器根据域名的层级，进行分级查询。 需要明确的是，每一级域名都有自己的NS记录，NS记录指向该级域名的域名服务器。这些服务器知道下一级域名的各种记录。 所谓”分级查询”，就是从根域名开始，依次查询每一级域名的NS记录，直到查到最终的IP地址，过程大致如下。 从”根域名服务器”查到”顶级域名服务器”的NS记录和A记录（IP地址） 从”顶级域名服务器”查到”次级域名服务器”的NS记录和A记录（IP地址） 从”次级域名服务器”查出”主机名”的IP地址 仔细看上面的过程，你可能发现了，没有提到DNS服务器怎么知道”根域名服务器”的IP地址。回答是”根域名服务器”的NS记录和IP地址一般是不会变化的，所以内置在DNS服务器里面。 下面是内置的根域名服务器IP地址的一个例子 上面列表中，列出了根域名（.root）的三条NS记录A.ROOT-SERVERS.NET、B.ROOT-SERVERS.NET和C.ROOT-SERVERS.NET，以及它们的IP地址（即A记录）198.41.0.4、192.228.79.201、192.33.4.12。 另外，可以看到所有记录的TTL值是3600000秒，相当于1000小时。也就是说，每1000小时才查询一次根域名服务器的列表。 目前，世界上一共有十三组根域名服务器，从A.ROOT-SERVERS.NET一直到M.ROOT-SERVERS.NET。 host 命令host命令可以看作dig命令的简化版本，返回当前请求域名的各种记录。 ➜ ~ host baidu.com baidu.com has address 220.181.38.148 baidu.com has address 39.156.69.79 baidu.com mail is handled by 20 jpmx.baidu.com. baidu.com mail is handled by 20 mx1.baidu.com. baidu.com mail is handled by 10 mx.maillb.baidu.com. baidu.com mail is handled by 15 mx.n.shifen.com. baidu.com mail is handled by 20 mx50.baidu.com. host命令也可以用于逆向查询，即从IP地址查询域名，等同于dig -x 常用参数 选项 说明 -a 查询DNS详细信息相当于-v -t -c(type) 指定查询类型，默认为IN -C 查询指定主机的完整的SOA记录； -r 禁用递归处理 -t(type) 指定查询类型 包括a、all、mx、ns -v 显示指令执行的详细信息 -w 如果域名服务器没有给出应答信息，则总是等待，直到域名服务器给出应答 -W&lt;时间&gt; 指定域名查询的最长时间，如果在指定时间内域名服务器没有给出应答信息，则退出指令 -4 使用IPv4 -6 使用IPv6 nslookup 命令nslookup4有两种工作模式，即“交互模式”和“非交互模式”。在“交互模式”下，用户可以向域名服务器查询各类主机、域名的信息，或者输出域名中的主机列表。而在“非交互模式”下，用户可以针对一个主机或域名仅仅获取特定的名称或所需信息。 进入交互模式，直接输入nslookup命令，不加任何参数，则直接进入交互模式，此时nslookup会连接到默认的域名服务器（即/etc/resolv.conf的第一个dns地址）。或者输入nslookup -nameserver/ip。进入非交互模式，就直接输入nslookup 域名就可以了 whois 命令whois命令用来查看域名的注册情况。]]></content>
  </entry>
  <entry>
    <title><![CDATA[Java基础-接口与抽象类]]></title>
    <url>%2F2018%2F11%2F09%2FJava%E5%9F%BA%E7%A1%80-%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[Java基础，接口与抽象类总结 接口与抽象类接口与抽象类的区别一个没有抽象方法的抽象类看起来跟接口相似，但是要注意以下区别： 一个类可以实现多个接口，但却只能继承最多一个抽象类。 抽象类可以包含具体方法；接口的所有方法都是抽象的。 抽象类可以声明和使用字段；接口则不能，但是可以创建静态的final常量。 抽象类中的方法可以是public、private、protected、packge；但是接口中的方法都是public。 抽象类可以定义构造函数；接口不能。 接口的特性 接口是抽象方法定义的集合,是一种特殊的抽象类 接口中可以包含方法也可以包含常量值 接口中只包含方法的定义,不包含方法的实现 接口中所有的方法都是抽象的 接口中成员的作用域修饰符都是public,常量的默认修饰符都是public static final 接口可以没有任何方法（标记接口-Mark Interface） 标记接口-Mark InterfaceJava中常用的三个标记接口分别是:RandomAccess、Cloneable、Serializable,在查看JDK源码的时候,我们会经常发现这些接口的存在，它们不包含任何的方法，但是却广泛的存在，这种接口我们称之为标记接口(Mark Interface),这些接口我们不用实现任何的方法，它们的作用就是当某个类实现这个接口的时候,我们就认为这个类拥有了接口标记的某种功能。]]></content>
      <tags>
        <tag>java</tag>
        <tag>接口</tag>
        <tag>抽象类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux磁盘空间不足问题排查]]></title>
    <url>%2F2018%2F10%2F09%2Flinux%E7%A3%81%E7%9B%98%E7%A9%BA%E9%97%B4%E4%B8%8D%E8%B6%B3%E9%97%AE%E9%A2%98%E6%8E%92%E6%9F%A5%2F</url>
    <content type="text"><![CDATA[利用df、du等命令排查linux文件系统磁盘空间不足问题 背景系统告警提示某台机器磁盘可用空间不足 排查过程 登录机器 列出文件系统的整体磁盘使用量 12345678$ df -hFilesystem Size Used Avail Use% Mounted on/dev/mapper/VolGroup-lv_root 8.3G 7.9G 400M 89% /tmpfs 1.9G 12K 1.9G 1% /dev/shm/dev/sda1 477M 121M 331M 27% /boot/dev/mapper/VolGroup-lv_data 90G 868M 90G 1% /data df显示 / 目录下磁盘使用率最高 cd / 查看当前目录下每个文件夹的大小1234567891011121314# du -sh *5.9M bin119M boot825M data164K dev29M etc0 filesystem.check1.3G home607M lib21M lib6416K lost+found4.0K media4.0K mnt8.8M opt 如果当前目录下有隐藏文件，可以使用命令du -sh .[!.]* .[!.] 是正则式, 意思是第一位是点, 第二位是除了点以外的字符, 第三位是任意字符或者不存在，后面可以再加一个” “来包括非隐藏文件 进入空间最大的目录，继续du -sh *，直到找到占用空间最大的目录或文件 相关命令df命令列出文件系统的整体磁盘使用量12345678910111213-a：列出所有的文件系统，包括系统特有的/proc等文件系统-k：以KB的容量显示各文件系统-m：以MB的容量显示各文件系统-h：以人们较易阅读的GB,MB,KB等格式自行显示-H：以M=1000K替代M=1024K的进位方式-T：连同该分区的文件系统名称（例如ext3）也列出-i：不用硬盘容量，而以inode的数量来显示 123df -hl 查看磁盘剩余空间 df -h 查看每个根路径的分区大小 du命令评估文件系统的磁盘使用量（常用于评估目录所占容量）1234567891011-a : 列出所有的文件与目录容量，因为默认仅统计目录下面的文件量而已；-h : 以人们较易读的容量格式（G/M）显示；-s : 列出总量，而不列出每个个别的目录占用了容量；-S : 不包括子目录下的总计，与-s有点差别；-k : 以KB列出容量显示；-m : 以MB列出容量显示。 与df不一样的是，du会直接到文件系统内查找所有的文件数据。 123456789101112131415161718du -sh [目录名] 返回目录总共占的容量。而不单独列出各子项占用的容量 du -lh --max-depth=1 查看当前目录下一级子文件和子目录占用的磁盘容量。 du -sm [文件夹] 返回该文件夹总M数 du -h [目录名] 查看指定文件夹下的所有文件大小（包含子文件夹）du -sh .[!.]* * | sort -hr 显示所有隐藏文件和非隐藏文件的大小并根据占用空间排序的语句du -a | sort -n -r | head -n 10 在当前目录下找出占用空间最大的前10大文件 sort: -n: 按照字符串表示的数字值来排序 -r: 按照反序排列 head: -n: 取出前多少行echo .[!.]* 查看所有隐藏文件]]></content>
      <tags>
        <tag>linux</tag>
        <tag>df</tag>
        <tag>du</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程书籍大全]]></title>
    <url>%2F2018%2F09%2F12%2F%E7%BC%96%E7%A8%8B%E4%B9%A6%E7%B1%8D%E5%A4%A7%E5%85%A8%2F</url>
    <content type="text"><![CDATA[100+ 经典技术书籍，涵盖：计算机系统与网络、系统架构、算法与数据结构、前端开发、后端开发、移动开发、数据库、测试、项目与团队、程序员职业修炼、求职面试 和 编程相关的经典书籍。 经典编程书籍大全这个列表综合了伯乐在线网站以往推荐经典书籍文章中的列表，以及在微信和微博中被广泛推荐的好书。虽然已经包括了100多本，覆盖的面也比较全。仍然有很多方面需要补充，而且相信还有很多没有被收录的好书。欢迎大家在 issues 中推荐或自荐。 计算机系统与网络 《图灵的秘密:他的生平、思想及论文解读》 《计算机系统概论》 《深入理解Linux内核》 《深入Linux内核架构》 《TCP/IP详解 卷1：协议》 《Linux系统编程（第2版）》 《Linux内核设计与实现（第3版）》 《深入理解计算机系统（原书第3版）》 《计算机程序的构造和解释（原书第2版）》 《编码：隐匿在计算机软硬件背后的语言》 《性能之颠：洞悉系统、企业与云计算》 《UNIX网络编程 卷1：套接字联网API（第3版）》 《UNIX网络编程 卷2：进程间通信》 《Windows核心编程(第5版)》 《WireShark网络分析就这么简单》 《WireShark网络分析的艺术》 编程通用 《设计原本》 《编程原本》 《代码大全》 《UNIX编程艺术》 《代码整洁之道》 《编程珠玑（第2版）》 《编程珠玑（续）》 《软件调试的艺术》 《修改代码的艺术》 《编程语言实现模式》 《编写可读代码的艺术》 《解析极限编程：拥抱变化》 《精通正则表达式（第3版）》 《编译原理（第2版）》龙书 《重构：改善既有代码的设计》 《七周七语言：理解多种编程范型》 《调试九法：软硬件错误的排查之道》 《程序设计语言：实践之路（第3版）》 《计算的本质：深入剖析程序和计算机》 《设计模式 : 可复用面向对象软件的基础》 《Head First 设计模式（中文版） 》（感谢@Great-Li-Xin 推荐 ） 算法与数据结构 《算法（第4版）》 《算法导论（原书第2版）》 《Python算法教程》 《算法设计与分析基础（第3版）》 《学习 JavaScript 数据结构与算法》 《数据结构与算法分析 : C++描述（第4版）》 《数据结构与算法分析 : C语言描述（第2版）》 《数据结构与算法分析 : Java语言描述（第2版）》 职业修炼与规划 《大教堂与集市》 《卓有成效的程序员》 《程序员的职业素养》 《程序员修炼之道：从小工到专家》 《软件开发者路线图：从学徒到高手》 《我编程，我快乐: 程序员职业规划之道》 《程序员的思维修炼：开发认知潜能的九堂课》 《高效程序员的45个习惯：敏捷开发修炼之道(修订版)》 大师访谈 《编程大师智慧》 《编程大师访谈录》 《编程人生 : 15位软件先驱访谈录》 《奇思妙想 : 15位计算机天才及其重大发现》 《图灵和ACM图灵奖》 架构/性能 《架构即未来》 《微服务设计》 《大数据日知录》 《企业应用架构模式》 《Web性能权威指南》 《SRE：Google运维解密》 《发布！软件的设计与部署》 《高扩展性网站的 50 条原则》 《大型网站技术架构:核心原理与案例分析》 《恰如其分的软件架构：风险驱动的设计方法》 《软件系统架构：使用视点和视角与利益相关者合作（第2版）》 Linux / Unix 《Linux/Unix 系统编程手册》（感谢@geekgao 的推荐） 《Unix 环境高级编程(第3版)》 《Unix/Linux 编程实践教程》 《鸟哥的 Linux 私房菜（基础学习篇）》和《鸟哥的 Linux 私房菜（服务器架设篇）》 《Linux 命令行与 shell 脚本编程大全（第3版）》 《只是为了好玩 : Linux 之父林纳斯自传》 Web前端 《高性能 JavaScript》 《锋利的 jQuery（第2版）》 《JavaScript 忍者秘籍》（感谢@joker-danta 补充推荐） 《编写可维护的 JavaScript》 《你不知道的 JavaScript（上）》 《你不知道的 JavaScript（中）》 《JavaScript 权威指南（第6版）》 《JavaScript 语言精粹（修订版）》 《JavaScript DOM编程艺术 （第2版）》 《JavaScript 高级程序设计（第3版）》 《JavaScript 异步编程：设计快速响应的网络应用》 《JavaScript设计模式与开发实践》 《JavaScript框架设计（第2版）》 《Effective JavaScript：编写高质量JavaScript代码的68个有效方法》 《HTML5 权威指南》 《HTML5 秘籍（第2版）》 《HTML5 与 CSS3 基础教程（第八版）》 《CSS 揭秘》 《CSS 设计指南（第3版）》 《CSS 权威指南（第3版）》 《深入浅出 HTML 与 CSS》 《ES6 标准入门（第三版）》 《深入理解 ES6》 Java开发 《Java8 实战》 《Java并发编程实战》 《Java性能权威指南》 《Java程序员修炼之道》 《实战Java高并发程序设计》 《Java编程思想 （第4版）》 《深入理解Java虚拟机（第2版）》 《Effective java 中文版（第2版）》 《Java核心技术·卷1：基础知识（原书第9版）》 《Java核心技术·卷2：高级特性（原书第9版）》 .NET/.NET Core 《C# 6.0 本质论》 《果壳中的C#：C#5.0权威指南》 《你必须知道的.NET（第2版）》 《深入理解C#（第3版）》 《Effective C#: 50 Specific Ways to Improve Your C#, Third Edition》 《More Effective C# (Includes Content Update Program): 50 Specific Ways to Improve Your C#, 2nd edition》 《Async in C# 5.0: Unleash the Power of Async》 《C#并发编程经典实例》 《C#多线程编程实战(原书第2版)》 《CLR via C#（第4版）》 《.NET本质论 第1卷:公共语言运行库》 《.NET探秘 : MSIL权威指南》 《Pro .NET Performance》 《Shared Source CLI Essentials》 《.NET 高级调试》 《Microsoft.NET 和 Windows 应用程序调试》 《微软.NET 程序的加密与解密》 《.NET Development Using the Compiler API》 《.NET设计规范 : 约定、惯用法与模式》 《编写高性能的.NET代码》 《Building Microservices with .NET Core》 《Microservices in .NET Core, with Examples in NancyFX》 Python 《集体智慧编程》 《笨办法学Python》 《Python基础教程》 《Python源码剖析》 《Head First Python》 《与孩子一起学编程》 《Python学习手册（第4版）》 《Python Cookbook（第3版）》 《Python参考手册（第4版）》 《Python核心编程（第3版）》 《Python科学计算（第2版）》 《利用 Python 进行数据分析》 《Think Python：像计算机科学家一样思考Python（第2版）》 《Python编程实战:运用设计模式、并发和程序库创建高质量程序》 《Python绝技：运用Python成为顶级黑客》 《Flask Web开发:基于Python的Web应用开发实战》 Android 《Android编程权威指南（第2版）》 《移动应用UI设计模式（第2版）》 《Android开发艺术探索》 iOS 《iOS编程实战》 《iOS编程（第4版）》 《Objective-C高级编程》 《Effective Objective-C 2.0：编写高质量iOS与OS X代码的52个有效方法》 PHP 《Head First PHP &amp; MySQL（中文版）》 《深入PHP：面向对象、模式与实践（第3版）》 C语言 《C标准库》 《C和指针》 《C专家编程》 《C陷阱与缺陷》 《C语言接口与实现》 《C程序设计语言（第2版）》 《C语言参考手册（第5版）》 C++ 《C++标准库》 《C++编程思想》 《C++语言的设计与演化》 《C++程序设计原理与实践》 《C++ Primer （中文第5版）》 《C++ Primer习题集(第5版) 》 《C++程序设计语言(第1-3部分)(原书第4版) 》 《Effective C++:改善程序与设计的55个具体做法(第3版)(中文版) 》 《More Effective C++:35个改善编程与设计的有效方法(中文版) 》&nbsp; 机器学习和数据挖掘 《数据之巅》 《矩阵分析》 《机器学习》 《统计学习方法》 《机器学习导论》 《推荐系统实践》 《机器学习实战》 《Web数据挖掘》 《深入浅出统计学》 《模式分类（第2版）》 《概率论与数理统计》 《统计学习基础(第2版)(英文) 》 《数据挖掘：概念与技术（第3版）》 《数据挖掘：实用机器学习工具与技术（原书第3版）》 《大数据：互联网大规模数据挖掘与分布式处理（第2版）》 数据库 《数据库系统概念》 感谢@noisnemid 推荐 《数据库系统实现》 《SQL应用重构》 《SQL Cookbook》 《高性能MySQL （第3版）》 《深入浅出SQL（中文版）》 《MySQL技术内幕 : InnoDB存储引擎（第2版）》 《深入浅出MySQL : 数据库开发、优化与管理维护》 《收获,不止SQL优化:抓住SQL的本质》 《SQL Server 性能优化与管理的艺术》 《SQL Server性能调优实战》 《T-SQL性能调优秘笈:基于SQL Server 2012窗口函数》 测试 《探索式软件测试》 《有效的单元测试》 《Google软件测试之道》 项目与团队 《人月神话》 《快速软件开发》 《人件（原书第3版）》 《门后的秘密：卓越管理的故事》 《极客与团队：软件工程师的团队生存秘笈》 《硝烟中的 Scrum 和 XP》 (感谢@geekgao 的推荐。 求职面试 《程序员面试金典（第5版）》 《编程之美 : 微软技术面试心得》 《金领简历：敲开苹果、微软、谷歌的大门》 《剑指Offer：名企面试官精讲典型编程题（纪念版）》 编程之外 《暗时间》 《数学之美》 《赢得朋友》 《精益创业》 《批判性思维》 《世界是数字的》 《程序员的数学》 《程序员健康指南》 《禅与摩托车维修艺术》 《关键对话：如何高效能沟通》 《写作法宝：非虚构写作指南》 《黑客与画家 : 来自计算机时代的高见》 《软件随想录（卷1）》《软件随想录（卷2）》 《如何把事情做到最好：改变全球9800万人的人生指导书》]]></content>
  </entry>
  <entry>
    <title><![CDATA[Memory Analyzer的使用记录]]></title>
    <url>%2F2018%2F09%2F05%2FMemory%20Analyzer%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[作为一个Java程序员，在系统出现内存泄漏等问题时，可以利用一些工具来分析dump文件，找到内存泄漏的原因，Memory Analyzer是一个很好的工具。 MAT使用记录下载地址http://www.eclipse.org/mat/downloads.php 问题一下载完成之后，运行弹窗报错：123An error has occurred. See the log file /Users/%username%/.eclipse/1899417313_macosx_cocoa_x86_64/configuration/1507391541586.log. 意思就是系统默认的workspace路径是只读的，只需更换默认位置就好了，需要注意添加参数时位置要在vm参数配置之前。 参考网友遇到的同样问题https://stackoverflow.com/questions/47909239/how-to-run-eclipse-memory-analyzer-on-mac-os 解决办法修改配置MemoryAnalyzer.ini，文件路径在你的下载位置/mat.app/Contents/Eclipse/MemoryAnalyzer.ini，最终的配置模样是 12345678910-startup../Eclipse/plugins/org.eclipse.equinox.launcher_1.5.0.v20180512-1130.jar-data/Users/jindanzi/mat.log--launcher.library../Eclipse/plugins/org.eclipse.equinox.launcher.cocoa.macosx.x86_64_1.1.700.v20180518-1200-vmargs-Xmx4086m-Dorg.eclipse.swt.internal.carbon.smallFonts-XstartOnFirstThread 必须在--launcher.library之前增加12-data/Users/jindanzi/mat.log 否则仍然报错 问题二MAT分析时报错An internal error occurred during: &quot;Parsing heap dump from XXX” 解决办法修改参数-vmargs增加内存大小 12-vmargs-Xmx4086m]]></content>
      <tags>
        <tag>MAT</tag>
        <tag>Memory Analyzer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Travis CI]]></title>
    <url>%2F2018%2F09%2F04%2FTravis-CI%2F</url>
    <content type="text"><![CDATA[前面介绍了Hexo搭建博客的过程，在使用的过程中，push到GitHub上面的实际上是hexo生成的静态文件，源代码依然还在本地。万一源文件丢失或者更换了电脑，怎么更新博客呢，于是想到将源文件也托管到GitHub上，但是每次都要push两次，有没有一个工具可以自动进行部署呢？ Travis CI介绍前面提到，我想做到把源代码放到GitHub上，只要要源代码提交，能自动将代码编译后上传到username.github.io仓库下，既托管了源代码又能自动进行部署，完美！！！这其实就是一个CI的过程，CI是啥，我就不做介绍，自行Google。 Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，同时他是在在线的服务，不像jenkins需要你本地打架服务器，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建。 项目网址：https://travis-ci.org/ 配置Travis CI 使用Github账号登录Travis CI，登录之后，点击页面左侧的加号 会列出你的GitHub项目，点击X开启项目 项目配置 配置项都选择默认，我们需要配置的是access token 生成Access Token 到GitHub -&gt; Settings -&gt; Developer settings -&gt; Personal access tokens点击生成一个token，权限都勾选上请注意一定要把token值复制下来，否则到其他页面就看不到内容了 将token添加到项目的环境变量中 配置自动构建脚本Travis CI是根据项目里面的.travis.yml文件来自动构建项目的，配置可以参考官方文档文档：https://docs.travis-ci.com/user/getting-started/ 我的该文件配置如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# Refrecnes:# https://zespia.tw/blog/2015/01/21/continuous-deployment-to-github-with-travis/# https://docs.travis-ci.com/user/languages/javascript-with-nodejs# https://github.com/iissnan/theme-next-docs/blob/master/.travis.yml# http://changyuheng.me/2015/when-hexo-static-site-meets-github-pages-and-travis-ci/language: node_jsnode_js: stablecache: directories: - node_modulesbefore_install: - export TZ=&apos;Asia/Shanghai&apos; # 更改时区install: - npm installbefore_script: - git submodule update --remote --mergescript: - hexo clean #清除 - hexo g #生成after_script: - git clone https://$&#123;GIT_PAGE_REF&#125; .deploy_git # GH_REF是最下面配置的仓库地址 - cd .deploy_git - git checkout master - cd ../ - mv .deploy_git/.git/ ./public/ # 这一步之前的操作是为了保留master分支的提交记录，不然每次git init的话只有1条commit - cd ./public - git config user.name &quot;github-username&quot; - git config user.email &quot;github-email&quot; - git add . - git commit -m &quot;Travis CI Auto Builder at `date +&quot;%Y-%m-%d %H:%M&quot;`&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GIT_PAGE_REF&#125;&quot; master:masterbranches: only: - masterenv: global: - GIT_PAGE_REF: github.com/Repositories/&#123;username&#125;.github.io.git# configure notifications (email, IRC, campfire etc)# please update this section to your needs!# https://docs.travis-ci.com/user/notifications/notifications: email: - your-email.com on_success: change on_failure: always 将这个文件放在项目的根目录下 测试CIpush一个文件到指定分支上，到Travis-CI网站上能看到如下页面 当状态变成passed，打开{username}.github.io就能看到文件的变化。如此一来，现在我们每次更新博客，只需要将变更push到源代码所在项目，Travis CI监控到变更之后就能自动进行构建发布了，是不是很6！！！]]></content>
      <tags>
        <tag>Travis</tag>
        <tag>CI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo搭建个人技术博客]]></title>
    <url>%2F2018%2F09%2F02%2FHexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[这是我的第一篇文章，主要用来记录Hexo + Github 搭建个人技术博客过程 Hexo + Github 搭建个人技术博客过程背景作为一个程序员，一直想搞一个个人的技术博客，虽然有很多技术博客网站（CSDN、简书等）都很好用，但本人主要想用记录博客的方式记录一些技术细节，方便以后好查找。本着免费的原则，网上找了很久，终于发现了Hexo，它可以很简单的使用GitHub托管的方式快速搭建一个博客，下面我记录下本人搭建的过程。 前提准备工作 拥有一个GitHub账号 安装Node.js、npm，并了解相关基础 安装Git客户端 本人使用的环境 mac node -v v8.8.1 git –version 2.12.2 参考 https://blog.csdn.net/u011475210/article/details/79023429 新建仓库在GitHub新建一个名为{username}.github.io的仓库，比如你的GitHub用户名是pig，就新建一个pig.github.io的仓库。将来博客搭建好了之后，就可以通过，https://pig.github.io来访问了。 配置SSH key要想提交代码到GitHub，必须有GitHub权限才行。GitHub可以通过配置SSH Key来解决本地跟GitHub服务器的连接安全问题。 1.配置全局name和email 123git config --global user.name "name" git config --global user.email "email" name和email是注册github的昵称和邮箱 2.生成Key 1ssh-keygen -t rsa -C &quot;your email&quot; 之后会让你输入GitHub账号和密码，输入文件名，默认为id_rsa，路径在~/.ssh/id_rsa 3.设置ssh key 1cat id_rsa.pub 将内容添加到GitHub -&gt; Settings -&gt; SSH and GPG Keys -&gt; New SSH Key Node.js、npm、git安装由于本人是使用的mac123brew install nodebrew install npmbrew install git Hexo安装hexo地址https://hexo.io/zh-cn/docs/index.html 1npm install -g hexo-cli hexo的使用请看文档，不再赘述。 主题配置hexo 我选择使用Next主题 下载主题 在博客根目录出打开命令行输入以下命令:1git clone https://github.com/theme-next/hexo-theme-next themes/next 将主题下载到博客的themes/next文件夹下 启用主题 只需在_config.yml中增加一行 theme: next 主题设定 Next主题相关的配置相当灵活，基本在/themes/next/_config.yml文件中，我的相关配置如下 1234Scheme: Mistsidebar: position: righthighlight_theme: night eighties 开始写文章在命令行界面，进入博客根目录，输入hexo new [post] 2018-09-02-my_first.md就会在source/_posts目录下自动创建名为2018-09-02-my_first.md的markdown文件，然后进行markdown编写就行了 本地预览运行hexo server命令启动Hexo，使用浏览器访问http://localhost:4000/即可浏览博客 发布到GitHub12345deploy: type: git repo: 你的博客git地址 branch: master message: 在_config.yml中配置GitHub相关项目配置后，运行hexo deploy，hexo会将博客生成的静态内容push到GitHub项目下，过一会你通过https://pig.github.io就可以在线看到博客内容了]]></content>
      <tags>
        <tag>Hexo</tag>
        <tag>github</tag>
        <tag>node</tag>
        <tag>npm</tag>
      </tags>
  </entry>
</search>
